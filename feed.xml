<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Teh Artikli</title>
    <link>http://knes1.github.io/</link>
    <atom:link href="http://knes1.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <description>Teh Artikli - tech and software development blog by Kre≈°imir Nesek</description>
    <language>en-gb</language>
    <pubDate>Sun, 12 Jul 2015 12:28:25 +0200</pubDate>
    <lastBuildDate>Sun, 12 Jul 2015 12:28:25 +0200</lastBuildDate>

    <item>
      <title>Counting Queries Per Request With Hibernate And Spring</title>
      <link>http://knes1.github.io//blog/2015/2015-07-08-counting-queries-per-request-with-hibernate-and-spring.html</link>
      <pubDate>Wed, 8 Jul 2015 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2015/2015-07-08-counting-queries-per-request-with-hibernate-and-spring.html</guid>
      	<description>
	&lt;p&gt;Hibernate is a powerful ORM tool, no doubt about it. In projects using Hibernate, it can sometimes become easy to forget that underneath it there are actual SQL queries being executed, sometimes many of them, and sometimes, well, too many. As you navigate the object graphs of your entities and admire collections being populated automagically, beware that if Hibernate&apos;s query generation is left unchecked, you can easily end up executing gazzilions of unnecessary SQL queries unknowingly (I&apos;ve actually seen thousands(!!) of queries executed per page render). Fortunately, these situations can usually be easily avoided once they are detected. I&apos;m going to present one idea how to keep query generation in check. &lt;/p&gt;
&lt;!-- more --&gt;&lt;p&gt;While there are many tools that can use JVM instrumentation to profile your app and likely tell you when, which and how many JPA/Hibernate/JDBC queries are being executed (&lt;a href=&quot;https://www.ej-technologies.com/products/jprofiler/overview.html&quot;&gt;JProfiler&lt;/a&gt; is my favorite), they need to hook up to JVM and are usually not &quot;always on&quot; as you develop. And you have to learn how to use them.&lt;br/&gt;To detect a common problem with excessive query generation though, a simple log line with the number of executed queries would suffice. Unfortunately, it seems that Spring MVC and Hibernate do not offer such a function out of the box (you could turn on query logging, but that will log each and every query and will soon become too verbose to follow). &lt;/p&gt;&lt;p&gt;In this article I will show you how to use a thing called Hibernate Interceptor to count executed queries per each web request in Spring MVC &lt;a href=&quot;https://github.com/knes1/todo&quot;&gt;application&lt;/a&gt; that uses JPA and Hibernate as the persistence implementation.&lt;/p&gt;&lt;p&gt;We will start by creating a HandlerInterceptor implementation (Spring MVC&apos;s equivalent of a filter) that will intercept incoming requests and initialze the statistics counters. HandlerInterceptors allow us to execute logic before the request processing is passed to controllers, after controller handler finishes execution (but before the view is rendered) and after the request is processed. We will use the HandlerInterceptor to gather statistics about a request so let&apos;s call it &lt;code&gt;RequestStatistcsInterceptor&lt;/code&gt;. Before action is handled over to the controllers, in the &lt;code&gt;preHandle(...)&lt;/code&gt; method of the &lt;code&gt;RequestStatistcsInterceptor&lt;/code&gt; we will initialize a query counter in the other important component - Hibernate Interceptor. Hibernate Interceptor allows us to intercept some of the Hibernate functions and the one that we&apos;re interested in is &lt;code&gt;onPrepareStatement()&lt;/code&gt; - it will be called each time Hibernate prepares an SQL statement to be sent to the database. We will do our counting there. Since each request is executed in its own thread, we&apos;ll need to have a counter per thread rather than a global counter so our interceptor&apos;s (let&apos;s call it &lt;code&gt;HibernateStatisticsInterceptor&lt;/code&gt; from now on) will have to be ThreadLocal. Since an ascii picture is worth a thousand of words, hereby I present the diagram of our intended setup: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    			Request
    			|
    			v
    			RequestStatisticsInterceptor#preHandle()
    				|
    				|------------------&amp;gt;HibernateStatisticsInterceptor#startCounter()
    				|                   :
    				v              (ThreadLocal Counter)
    				Controller          :                             ______
    				    |               :                            /      \
    				    |----Query 1---(+1)-----------------------&amp;gt;  \______/
    				    |----Query 2---(+1)-----------------------&amp;gt;  \      /
    				    ...             :                            \  DB  /
    				    |----Query N---(+1)-----------------------&amp;gt;  \______/
    				    |               :
    			RequestStatisticsInterceptor#afterCompletion(...)
    				|                   :
    				|&amp;lt;---queryCount-----HibernateStatisticsInterceptor#getQueryCount()
    				|------------------&amp;gt;HibernateStatisticsInterceptor#clearCounter()
    				|
    				Log queryCount
    				|
    			|
    			V
    			Response
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ok, now that everthing is clear let&apos;s take a look at the code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class RequestStatisticsInterceptor implements AsyncHandlerInterceptor {

	private ThreadLocal&amp;lt;Long&amp;gt; time = new ThreadLocal&amp;lt;&amp;gt;();

	private static final Logger log = LoggerFactory.getLogger(RequestStatisticsInterceptor.class);

	@Autowired
	private HibernateStatisticsInterceptor statisticsInterceptor;

	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		time.set(System.currentTimeMillis());
		statisticsInterceptor.startCounter();
		return true;
	}

	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
		Long queryCount = statisticsInterceptor.getQueryCount();
		modelAndView.addObject(&amp;quot;_queryCount&amp;quot;, queryCount);
	}

	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
		long duration = System.currentTimeMillis() - time.get();
		Long queryCount = statisticsInterceptor.getQueryCount();
		statisticsInterceptor.clearCounter();
		time.remove();
		log.info(&amp;quot;[Time: {} ms] [Queries: {}] {} {}&amp;quot;, duration, queryCount, request.getMethod(), request.getRequestURI());
	}

	@Override
	public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		//concurrent handling cannot be supported here
		statisticsInterceptor.clearCounter();
		time.remove();
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you may have noticed there are some additional things in here:&lt;br/&gt;- we&apos;re also recording time (since we already have a stats interceptor, why not also record the execution time of each request - it&apos;s a useful stat)&lt;br/&gt;- in postHandle we&apos;re adding query count to the model - while it&apos;s not stricly necessary, it allows us to print query counts on the actual page we&apos;re rendering while we&apos;re developing the application&lt;br/&gt;- we&apos;re implementing &lt;code&gt;AsyncHandlerInterceptor&lt;/code&gt; and basically ignoring async requests as we cannot use the above approach for async requests because they request execution may happen in a different thread than the one that triggers the interceptor and hence we can&apos;t really use &lt;code&gt;ThreadLocal&lt;/code&gt; to store the counters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class HibernateStatisticsInterceptor extends EmptyInterceptor {

	private static final Logger log = LoggerFactory.getLogger(HibernateStatisticsInterceptor.class);

	private ThreadLocal&amp;lt;Long&amp;gt; queryCount = new ThreadLocal&amp;lt;&amp;gt;();

	public void startCounter() {
		queryCount.set(0l);
	}

	public Long getQueryCount() {
		return queryCount.get();
	}

	public void clearCounter() {
		queryCount.remove();
	}

	@Override
	public String onPrepareStatement(String sql) {
		Long count = queryCount.get();
		if (count != null) {
			queryCount.set(count + 1);
		}
		//log.info(sql);
		return super.onPrepareStatement(sql);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nothing too unusual here. It&apos;s worth noting that it&apos;s a good idea to ensure that clearCounter is called for each time startCounter is called (and in the same thread). We need to make sure to clear &lt;code&gt;ThreadLocal&lt;/code&gt;s to avoid counters leaking to another thread or possibly memory leaks.&lt;/p&gt;&lt;p&gt;The last tricky part to solve is the fact that we need to reference &lt;code&gt;HibernateStatisticsInterceptor&lt;/code&gt; from the &lt;code&gt;RequestStatisticsInterceptor&lt;/code&gt; which means that &lt;code&gt;HibernateStatisticsInterceptor&lt;/code&gt; needs to be Spring managed bean. Luckily, the answer for Spring Boot) can be found on StackOverflow: &lt;a href=&quot;http://stackoverflow.com/questions/25283767/how-to-use-spring-managed-hibernate-interceptors-in-spring-boot&quot;&gt;How to use Spring managed Hibernate interceptors in Spring Boot?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;It is necessary to provide a custom &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; (I love this short and concise name!) in order to inject our HibernateStatisticsInterceptor to JPA property &lt;code&gt;hibernate.ejb.interceptor&lt;/code&gt;. We also need to register &lt;code&gt;RequestStatisticsInterceptor&lt;/code&gt; and configure it to intercept all requests.&lt;/p&gt;&lt;p&gt;Here is the complete Spring Boot configuration for a simple application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application {


	public static void main(String[] args) {
		start();
	}

	public static void start() {
		SpringApplication.run(Application.class);
	}

	@Bean
	public LocalContainerEntityManagerFactoryBean entityManagerFactory(
			EntityManagerFactoryBuilder factory, DataSource dataSource,
			JpaProperties properties) {
		Map&amp;lt;String, Object&amp;gt; jpaProperties = new HashMap&amp;lt;&amp;gt;();
		jpaProperties.putAll(properties.getHibernateProperties(dataSource));
		jpaProperties.put(&amp;quot;hibernate.ejb.interceptor&amp;quot;, hibernateInterceptor());
		return factory.dataSource(dataSource).packages(&amp;quot;io.github.knes1.todo.model&amp;quot;)
				.properties(jpaProperties).build();
	}

	@Bean
	public HibernateStatisticsInterceptor hibernateInterceptor() {
		return new HibernateStatisticsInterceptor();
	}

	@Configuration
	public static class WebApplicationConfig extends WebMvcConfigurerAdapter {

		@Autowired
		RequestStatisticsInterceptor requestStatisticsInterceptor;

		@Bean
		public RequestStatisticsInterceptor requestStatisticsInterceptor() {
			return new RequestStatisticsInterceptor();
		}

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(requestStatisticsInterceptor).addPathPatterns(&amp;quot;/**&amp;quot;);
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the above config doesn&apos;t work for you because you use older Spring versions, take a look at this blog post for an alternative configuration: &lt;a href=&quot;http://blog.krecan.net/2009/01/24/spring-managed-hibernate-interceptor-in-jpa/comment-page-1/&quot;&gt;Spring managed Hibernate interceptor in JPA&lt;/a&gt;&lt;/p&gt;&lt;p&gt;To demonstrate what we achieved, I&apos;ve built a small todo list application. Source code is available on &lt;a href=&quot;https://github.com/knes1/todo&quot;&gt;GitHub&lt;/a&gt;.&lt;br/&gt;After running the application and creating a few todo items, here&apos;s what shows up in the log:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2015-07-10 11:26:55.707  INFO 85977 --- [qtp545373187-17] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 251 ms] [Queries: 1] GET /
2015-07-10 11:26:59.347  INFO 85977 --- [qtp545373187-19] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 166 ms] [Queries: 2] GET /todos/1/delete
2015-07-10 11:26:59.361  INFO 85977 --- [qtp545373187-16] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 7 ms] [Queries: 1] GET /
2015-07-10 11:27:12.070  INFO 85977 --- [qtp545373187-17] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 21 ms] [Queries: 1] POST /todos
2015-07-10 11:27:12.085  INFO 85977 --- [qtp545373187-18] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 9 ms] [Queries: 1] GET /
2015-07-10 11:27:25.058  INFO 85977 --- [qtp545373187-15] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 4 ms] [Queries: 1] POST /todos
2015-07-10 11:27:25.072  INFO 85977 --- [qtp545373187-19] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 9 ms] [Queries: 1] GET /
2015-07-10 11:27:30.292  INFO 85977 --- [qtp545373187-18] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 5 ms] [Queries: 1] POST /todos
2015-07-10 11:27:30.304  INFO 85977 --- [qtp545373187-15] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 8 ms] [Queries: 1] GET /
2015-07-10 11:27:32.135  INFO 85977 --- [qtp545373187-19] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 24 ms] [Queries: 2] GET /todos/4/completed
2015-07-10 11:27:32.143  INFO 85977 --- [qtp545373187-16] i.g.k.t.u.RequestStatisticsInterceptor   : [Time: 4 ms] [Queries: 1] GET /
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have timings and query counts for each request - now we can easily detect early if something went wrong because we&apos;ll see query counts suddenly increase (if we for example hit the so called N+1 problems, or if we carelessly navigate through collections). As a bonus, since we included query counts in the model, we can even print them out on the page while we do development (notice the query count for current page in the screenshot below). Here&apos;s a screenshot form the sample application:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/todolist.png&quot; width=&quot;600px&quot;&gt;&lt;/p&gt;&lt;p&gt;And that&apos;s all I have for this post - I hope I&apos;ve helped in keeping query generation under control!&lt;/p&gt;&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/knes1/todo&quot;&gt;Sample application: Todo List&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25283767/how-to-use-spring-managed-hibernate-interceptors-in-spring-boot&quot;&gt;How to use Spring managed Hibernate interceptors in Spring Boot?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.krecan.net/2009/01/24/spring-managed-hibernate-interceptor-in-jpa/comment-page-1/&quot;&gt;Spring managed Hibernate interceptor in JPA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
	</description>
    </item>
    <item>
      <title>I Discovered JBake</title>
      <link>http://knes1.github.io//blog/2015/2015-06-04-i-discovered-jbake.html</link>
      <pubDate>Thu, 4 Jun 2015 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2015/2015-06-04-i-discovered-jbake.html</guid>
      	<description>
	&lt;p&gt;When I was starting this blog and was researching what options are out there in terms of blogging systems, I was looking for a simple developer focused blogging solution that I could use for publishing posts hosted on github pages. I found &lt;a href=&quot;http://octopress.org/&quot;&gt;Octopress&lt;/a&gt; and decided to use it, mostly because it popped up often in Google search results and had a tag line that I liked: A blogging framework designed for hackers. And it was fine.&lt;/p&gt;&lt;p&gt;Recently though, I stumbled upon &lt;a href=&quot;http://jbake.org/&quot;&gt;JBake&lt;/a&gt;. I liked it so much that I&apos;m switching my blog away from Octopress.&lt;!-- more --&gt; JBake is something that I often thought about creating myself. Here&apos;s what I like about it:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It&apos;s written in Java and uses Java related templating technologies that I&apos;m familiar with. While I&apos;m no stranger to Ruby, I am primarily Java developer and I&apos;m happy that I can now use Freemarker as a template engine for my blog pages.&lt;/li&gt;
  &lt;li&gt;It&apos;s simple. It has templates and content folders where you put, well, templates and content and that&apos;s about it. It took me about 10 minutes to understand the structure and start customizing. When I&apos;m publishing a post with Octopress, I have to go through a tutorial every time to refresh my memory on how to do it (admittedly, the reason for this is in part because I don&apos;t publish very often)&lt;/li&gt;
  &lt;li&gt;I find it easy to customize (for my simple needs). I don&apos;t even have to read the docs about how to do it - it&apos;s logical and self-explanatory.&lt;/li&gt;
  &lt;li&gt;Managing Octopress through git (as recommended on Octopress web site) is too confusing for me. For JBake based blog, I have one git repository in which I keep the sources (templates/content/assets etc.) and another one for generated output folder in order to push it to github pages.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;There&apos;s one thing I miss in JBake - I wish it had &quot;watch for changes&quot; mode that would automatically build the pages once a change in content or templates is detected.&lt;/p&gt;&lt;p&gt;Finally, to be fair, in retrospect I probably shouldn&apos;t have chosen Octopress. It&apos;s not what I&apos;ve been looking for in the first place. Without knowing JBake existed, I probably should have used &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; - the engine that Octopress is built on top of. JBake is in fact inspired by Jekyll and Jekyll provides the simplicity that I was actually looking for.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Part 1: The value of @Value</title>
      <link>http://knes1.github.io//blog/2015/2015-02-07-part1-the-value-of-at-value.html</link>
      <pubDate>Sat, 7 Feb 2015 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2015/2015-02-07-part1-the-value-of-at-value.html</guid>
      	<description>
	&lt;p&gt;Did it ever happen to you that after spending some time and gaining experience with a framework or a programming language, you learn things that would have made your programmer&apos;s life much easier if you had known them right from the start? You would have done things differently, more quickly, in a simpler, cleaner and more maintainable way?&lt;/p&gt;&lt;p&gt;I decided to write a series of posts about features and aspects of Spring Framework (the framework in which I spend most of my professional software development time) that I found useful (usually far later than I&apos;d like to admit :) ), but which are often not covered in entry level guides and tutorials.&lt;/p&gt;&lt;p&gt;In this first post I would like to discuss the &lt;code&gt;@Value&lt;/code&gt; annotation.&lt;br/&gt;&lt;!-- more --&gt;&lt;/p&gt;&lt;p&gt;I started working with Spring framework since the 2.5 version. Later on, when 3.0 was released, JavaConfig became the part of the core framework along with the &lt;code&gt;@Value&lt;/code&gt; that was part of it. I unfortunately didn&apos;t notice that improvement for quite some time, mostly because the projects I worked on relied on XML based config.&lt;/p&gt;&lt;p&gt;Here&apos;s what &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Value.html&quot;&gt;Spring javadocs&lt;/a&gt; say about &lt;code&gt;@Value&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Annotation at the field or method/constructor parameter level that indicates a default value expression for the affected argument.&lt;/p&gt;&lt;p&gt;Typically used for expression-driven dependency injection. Also supported for dynamic resolution of handler method parameters, e.g. in Spring MVC.&lt;/p&gt;&lt;p&gt;A common use case is to assign default field values using &quot;#{systemProperties.myProp}&quot; style expressions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Let&apos;s see how we can make use of it.&lt;/p&gt;&lt;h4&gt;Assigning values from property files&lt;/h4&gt;&lt;p&gt;This is likely the most common use case for &lt;code&gt;@Value&lt;/code&gt; annotation. &lt;code&gt;@Value&lt;/code&gt; allows us to easily inject a value from a property file to, for example, a bean&apos;s field or a constructor argument.&lt;/p&gt;&lt;p&gt;If we had a property file that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.name = My Excellent Application
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we could use that property definition in, say, a controller using&lt;code&gt;@Value(&amp;quot;${propertyName}&amp;quot;)&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Controller
public class HelloController {
	
	@Value(&amp;quot;${app.name}&amp;quot;)
	private String appName;

	@RequestMapping(&amp;quot;/&amp;quot;)
	@ResponseBody
	public String hello() {
		return &amp;quot;Hello from &amp;quot; + appName;
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code in the example will read the property app.name from property file and inject it into &lt;code&gt;appName&lt;/code&gt; field. The &lt;code&gt;${...}&lt;/code&gt; syntax is Spring&apos;s property placeholder syntax used in property placeholder replacement mechanism. If &lt;code&gt;app.name&lt;/code&gt; is not defined, then an exception will be thrown. Which brings us to a less known fact about property placeholders - it&apos;s possible to set a default value for a property that Spring would use if the property is not defined. The syntax for default values in property placeholders is &lt;code&gt;${property:defaultValue}&lt;/code&gt;. You can read about it the javadocs for &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/PlaceholderConfigurerSupport.html&quot;&gt;PlaceholderConfigurerSupport&lt;/a&gt; class. I find default values quite useful, especially in situations where a particular property of a bean is not likely to be changed in different environments and as such you don&apos;t want to introduce it needlessly into a property file, but still want to give yourself an option to change your mind later. If we were to modify our example to use a default value, it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Controller
public class HelloController {
	
	@Value(&amp;quot;${app.name:My Excellent Application}&amp;quot;)
	private String appName;

	@RequestMapping(&amp;quot;/&amp;quot;)
	@ResponseBody
	public String hello() {
		return &amp;quot;Hello from &amp;quot; + appName;
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Injecting a SpringEL dynamically evaluated value&lt;/h4&gt;&lt;p&gt;Do you remember &lt;code&gt;@Value&lt;/code&gt;&apos;s javadoc that was shown previously? It described a &lt;code&gt;#{...}&lt;/code&gt; syntax rather than property replacement &lt;code&gt;${...}&lt;/code&gt; syntax that we used in our example. What&apos;s the difference? The &lt;code&gt;#{...}&lt;/code&gt; syntax invokes Spring Expression Language (SpringEL) and evaluates the expression dynamically. For example we could obtain a value from the system settings:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Value(&amp;quot;#{systemSettings[&amp;#39;user.region&amp;#39;]}&amp;quot;)
private String locale; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above expression works because systemSettings is a variable that&apos;s always available to SpringEL when it&apos;s invoked in this context (e.g. when configuring beans).&lt;/p&gt;&lt;p&gt;We may even inject a return value of a method of another bean:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Value(&amp;quot;#{&amp;#39;V1.0S&amp;#39; + migrationService.version}&amp;quot;)
private String version;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example Spring will inject string &quot;V1.0S&quot; prepended to the return value of method &lt;code&gt;getVersion()&lt;/code&gt; of a bean with name &lt;code&gt;migrationService&lt;/code&gt; (all beans in Spring&apos;s context are available as variables in SpringEL).&lt;/p&gt;&lt;p&gt;To conclude,&lt;code&gt;@Value&lt;/code&gt; annotation is indispensable asset when configuring your beans. When pursing convention-over-configuration style, default values for property placeholders used in&lt;code&gt;@Value&lt;/code&gt; configs may come in handy. And finally, always keep on your mind that you can invoke SpringEL to help you to simplify scenarios that may otherwise require complex config or workarounds. &lt;/p&gt;
&lt;hr&gt;&lt;p&gt;Did you find this article helpful? What is your favorite Spring feature? Do you have a related blog post? Feel welcome to leave feedback or comments below :)&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Concise Integration Tests That Contain Mocks In Spring Framework</title>
      <link>http://knes1.github.io//blog/2014/2014-08-18-concise-integration-tests-that-contain-mocks-in-spring-framework.html</link>
      <pubDate>Mon, 18 Aug 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2014/2014-08-18-concise-integration-tests-that-contain-mocks-in-spring-framework.html</guid>
      	<description>
	&lt;p&gt;In this post I&apos;ll write about how to reduce a bit of boilerplate code when writing tests in Spring Framework in a situation where we don&apos;t want to bring up the whole Spring context in order to test if only a subset of components are working together correctly.&lt;/p&gt;&lt;p&gt;Our goal will be to have Spring load only the components that we are interested in testing, mock out everything else and do it in a simple and readable way.&lt;/p&gt;
&lt;!-- more --&gt;&lt;p&gt;Let&apos;s start with an example. Our example application has a &lt;code&gt;UserService&lt;/code&gt; with a &lt;code&gt;registerNewUser&lt;/code&gt; method. Whenever a new user is added to the system, &lt;code&gt;UserService&lt;/code&gt;&apos;s &lt;code&gt;registerNewUser&lt;/code&gt; method is called. This method adds the user to the system, hashes user&apos;s password, stores user data to the database, updates application&apos;s user statistics and sends out confirmation e-mail. To accomplish these tasks, &lt;code&gt;UserService&lt;/code&gt; depends on &lt;code&gt;PasswordEncoder&lt;/code&gt;, &lt;code&gt;UserRepository&lt;/code&gt;, &lt;code&gt;StatisticsService&lt;/code&gt; and &lt;code&gt;EmailService&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;We want to write an integration test that will verify that when &lt;code&gt;registerNewUser&lt;/code&gt; is called, the user is indeed stored correctly to the database and user password is hashed. To do this, we want actual &lt;code&gt;UserService&lt;/code&gt; implementation brought up in our test Spring context, along with &lt;code&gt;PasswordEncoder&lt;/code&gt; and persistence related components and have everything else mocked out (side note: I&apos;m using the term mock here, but since we&apos;re not verifying interactions with mock objects in the example tests, some testing vocabularies would refer to these kind of test objects as dummy objects).&lt;/p&gt;&lt;p&gt;To mock out the beans we&apos;ll be using &lt;a href=&quot;https://code.google.com/p/mockito/&quot;&gt;Mockito&lt;/a&gt; library. Our JUnit test will be run with &lt;code&gt;SpringJUnit4ClassRunner&lt;/code&gt;. Demo application&apos;s code is available at &lt;a href=&quot;https://github.com/knes1/springmockedtests&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Here&apos;s the test class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader=AnnotationConfigContextLoader.class)
public class UserServiceImplIntegrationTest {

	@Autowired
	UserService userService;

	@Autowired
	UserRepository userRepository;

	@Transactional
	@Test
	public void testRegisterNewUser() {
		final String userName = &amp;quot;someone&amp;quot;;
		final String password = &amp;quot;somepass&amp;quot;;
		userService.registerNewUser(new User(&amp;quot;someone@example.com&amp;quot;, userName, password));
		User user = userRepository.findByUserName(userName);
		Assert.assertNotNull(user);
		Assert.assertTrue(SCryptUtil.check(password, user.getPassword()));
	}

	@Configuration
	@Import(TestAppConfig.class)
	static class ContextConfiguration {

		@Bean
		public UserService userService() {
			return new UserServiceImpl();
		}

		@Bean
		public PasswordEncoder passwordEncoder() {
			return new SCryptPasswordEncoder();
		}

		@Bean
		public EmailService emailService() {
			return Mockito.mock(EmailService.class);
		}

		@Bean
		public StatisticsService statisticsService() {
			return Mockito.mock(StatisticsService.class);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&apos;s examine the code:&lt;/p&gt;&lt;p&gt;With &lt;code&gt;@ContextConfiguration(loader=AnnotationConfigContextLoader.class)&lt;/code&gt; we instruct Spring to load test context configuration from the annotated class. We have defined the configuration class as a static inner class of our test class (&lt;code&gt;ContextConfiguration&lt;/code&gt;). We import common configuration that will be shared among different integration tests form &lt;code&gt;TestAppConfig.class&lt;/code&gt;. In the &lt;code&gt;ContextConfiguration&lt;/code&gt; we define the beans whose actual implementation will participate in the integration test (&lt;code&gt;UserServiceImpl&lt;/code&gt; and &lt;code&gt;SCryptPasswordEncoder&lt;/code&gt;) and we mock out their dependencies (&lt;code&gt;EmailService&lt;/code&gt;, &lt;code&gt;StatisticsService&lt;/code&gt;). The inspiration for this pattern of writing integration tests that combine actual and mocked beans originate from great answers found in this stack overflow question: &lt;a href=&quot;http://stackoverflow.com/questions/2457239/injecting-mockito-mocks-into-a-spring-bean&quot;&gt;Injecting Mockito mocks into a Spring bean&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The idea is to keep common configuration that we plan to reuse between various tests in &lt;code&gt;TestAppConfig.class&lt;/code&gt; (in our example, &lt;code&gt;TestAppConfig&lt;/code&gt; contains test database, JPA and Spring-data configuration) and add keep per test specific configuration in an inner class of the test class. We also manually define beans that we need to mock out in order for Spring to satisfy all the dependencies of the beans we plan to test.&lt;/p&gt;&lt;p&gt;This works just fine, expect in certain more complex integration tests, there will be a lot of beans to be mocked out, and we have to write lots of boilerplate code to define those. For example, to mock out &lt;code&gt;EmailService&lt;/code&gt; class we write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Bean
public EmailService emailService() {
	return Mockito.mock(EmailService.class);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Characters &quot;EmailService&quot; are typed three times (Type definition, method name and as a parameter to mock method) and we hat to write 4 lines of code. If there&apos;s 10 beans to mock out, that&apos;s a lot of typing! Is there a way to make things more concise? It turns out there is, using the &lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;. We will create an annotation that we&apos;ll use to specify which classes we plan to mock out, and then implement &lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt; that will look for the annotation and register bean definitions we specified as a mocked beans.&lt;/p&gt;&lt;p&gt;Here&apos;s the custom annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Import(MockImportRegistar.class)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MockedBeans {
	/**
	 * Types that need to be mocked.
	 * @return
	 */
	Class&amp;lt;?&amp;gt;[] value() default {};
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&apos;s the code for &lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt; implementation (note that we referenced &lt;code&gt;MockImportRegistar&lt;/code&gt; with &lt;code&gt;@Import&lt;/code&gt; in &lt;code&gt;MockedBean&lt;/code&gt; annotation above):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class MockImportRegistar implements ImportBeanDefinitionRegistrar {

	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		if (importingClassMetadata.isAnnotated(MockedBeans.class.getName())) {
			Object mockedBeanTypesValue = importingClassMetadata.getAnnotationAttributes(MockedBeans.class.getName()).get(&amp;quot;value&amp;quot;);
			if (mockedBeanTypesValue instanceof Class&amp;lt;?&amp;gt;[]) {
				Class&amp;lt;?&amp;gt;[] mockedBeanTypes = (Class&amp;lt;?&amp;gt;[]) mockedBeanTypesValue;
				if (mockedBeanTypes != null &amp;amp;&amp;amp; mockedBeanTypes.length &amp;gt; 0) {
					mockSpecifiedBeanTypes(registry, mockedBeanTypes);
				}
			}
		}
	}

	private void mockSpecifiedBeanTypes(BeanDefinitionRegistry registry, Class&amp;lt;?&amp;gt;[] mockedBeanTypes) {
		for (Class&amp;lt;?&amp;gt; mockedType : mockedBeanTypes) {
			registry.registerBeanDefinition(&amp;quot;mock&amp;quot; + mockedType.getSimpleName(),
			BeanDefinitionBuilder
					.rootBeanDefinition(Mockito.class)
					.setFactoryMethod(&amp;quot;mock&amp;quot;)
					.addConstructorArgValue(mockedType.getName())
					.getBeanDefinition()
			);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that have defined the annotation and the registrar we can rewrite the &lt;code&gt;ContextConfiguration&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Configuration
@Import(TestAppConfig.class)
@MockedBeans({EmailService.class, StatisticsService.class})
static class ContextConfiguration {

	@Bean
	public UserService userService() {
		return new UserServiceImpl();
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new SCryptPasswordEncoder();
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Beans that we need to be mocked are now defined using our &lt;code&gt;@MockedBeans&lt;/code&gt; annotation. I find this approach more concise, simpler and easier to maintain, especially for more complex integration tests.&lt;/p&gt;
	</description>
    </item>

  </channel> 
</rss>
